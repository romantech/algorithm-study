/*
주어진 숫자 n을 1과 2로 표현할 수 있는 모든 방법의 개수를 찾는 문제
방법의 개수를 알아낸 후 1234567로 나눈 나머지 리턴 (중간 과정도 나눠야함)
n에 대한 방법의 개수는 피보나치수열 원리와 동일
1 <= n <= 2000

참고로 1234567 MOD로 나누는 이유는 숫자를 MOD로 제한하여 오버플로우를 방지하기 위함
만약 MOD로 나누지 않으면 큰 숫자일 때 변수가 가질 수 있는 값의 범위를 넘어설 때 문제가 발생함
예를들어 8비트 시스템에선 2^8 = 256개의 다른 값 지정 가능 -> 0부터 시작하므로 최대 255까지의 값 저장 가능
만약 255 + 1 = 256이라면 오버플로우가 발생해서 값은 0으로 롤오버되는 문제가 발생함
MOD로 나누면 연산 결과는 항상 0~ MOD - 1 값을 가지게 됨
0 % 5 = 0, ..., 5 % 5 = 0, 6 % 5 = 1, 7 % 5 = 2, 8 % 5 = 3, 9 % 5 = 4, 10 % 5 = 0
*/

function solution(n) {
  const memo = [1, 1];
  const MOD = 1234567;

  for (let i = 2; i <= n; i += 1) {
    memo[i] = (memo[i - 1] + memo[i - 2]) % MOD;
  }

  return memo[n];
}

const cases = [
  {
    input: 1,
    output: 1,
  },
  {
    input: 2,
    output: 2, // [1, 1], [2]
  },
  {
    input: 3,
    output: 3, // [1, 1, 1], [1, 2], [2, 1]
  },
  {
    input: 4,
    output: 5, // [1, 1, 1, 1], [1, 2, 1], [1, 1, 2], [2, 1, 1], [2, 2]
  },
];

cases.forEach(({ input, output }) => {
  console.log(solution(input) === output);
});
